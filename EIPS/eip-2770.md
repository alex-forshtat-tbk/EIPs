---
eip: 2770
title: Meta-Transactions Forwarder Contract
author: Dror Tirosh <dror.tirosh@gmail.com>, Alex Forshtat <forshtat1@gmail.com>
discussions-to: https://github.com/ethereum/EIPs/pull/2770
status: Draft
type: Standards Track
category: ERC
created: 2020-07-01
requires: 712
---

## Simple Summary
This proposal describes a singleton Forwarder contract that enables various meta-transaction systems to co-exist without a need for recipient contracts to add support for them individually.

## Abstract
The standard way in Ethereum for smart contracts to authenticate callers is by checking the value of `msg.sender` (`CALLER 0x33`).
For externally-owned accounts it means that the transaction signature is validated on the protocol level.
On the other hand, this introduces a requirement for the caller account to have a sufficient amount of Ether to pay for the gas.
In this ERC we propose to introduce a singleton contract whose responsibility is to validate transaction signatures on-chain,
expose the signer to the destination contract and leave the gas calculation outside of the picture.

## Motivation
Ethereum is a leading platform for dapps and user acquisition is hard when having Ether is a prerequisite for even trying out the dapp.
This lead to the emergence of the concept called ‘meta-transactions’, where signing and paying for gas is separated.
On the other hand, there was no standard solution and a set of competing approaches emerged.
Here we propose to establish a piece of shared infrastructure to build upon.

## Specification
The Forwarder contract operates by accepting a signed typed data together with it's ERC-712 signature,
performs signature verification of incoming data, appends the signer address to the data field and performs a call to the target.

#### Forwarder data type registration
Request struct MUST contain the following fields in this exact order:
```
struct ForwardRequest {
   address from;
   address to;
   uint256 value;
   uint256 gas;
   uint256 nonce;
   bytes data;
}
```
`from` - an externally-owned account making the request \
`to` - a destination address, normally a smart-contract\
`value` - an amount of Ether to transfer to the destination\
`gas` - an amount of gas limit to set for the execution\
`nonce` - an on-chain tracked nonce of a transaction\
`data` - the data to be sent to the destination 

The request struct MAY include any other fields, including nested structs, if necessary.
In order for the Forwarder to be able to enforce the names of the fields of this struct, only registered types are allowed.

Registration MUST be performed in advance by a call to the following method:
```
function registerRequestType(string typeName, string typeSuffix)
```
`typeName` - a name of a type being registered\
`typeSuffix` - an ERC-712 compatible description of a type

For example, after calling 
```
registerRequestType("ExtendedRequest", "uint256 x,bytes z,ExtraData extraData)ExtraData(uint256 a,uint256 b,uint256 c)")
```
the following ERC-712 type will be registered with forwarder:
```
/* primary type */
struct ExtendedRequest {
   address from;
   address to;
   uint256 value;
   uint256 gas;
   uint256 nonce;
   bytes data;
   uint256 x;
   bytes z;
   ExtraData extraData;
}

/* subtype */
struct ExtraData {
   uint256 a;
   uint256 b;
   uint256 c;
}
```

#### Signature verification

The following method performs an ERC-712 signature check on a request:
```
function verify(
   ForwardRequest forwardRequest,
   bytes32 domainSeparator,
   bytes32 requestTypeHash,
   bytes suffixData,
   bytes signature
) view;
```
`forwardRequest` - an instance of the `ForwardRequest` struct  
`domainSeparator` - caller-provided domain separator to prevent signature reuse across dapps (refer to ERC-712)
`requestTypeHash` - hash of the registered relay request type
`suffixData` - RLP-encoding of the remainder of the request struct
`signature` - an ERC-712 signature on the concatenation of `forwardRequest` and `suffixData`

#### Command execution

In order for the Forwarder to perform an operation, the following method is to be called: 
```
function execute(
   ForwardRequest forwardRequest,
   bytes32 domainSeparator,
   bytes32 requestTypeHash,
   bytes suffixData,
   bytes signature
)
public
payable
returns (
   bool success,
   bytes memory ret
)
```
 
Performs the ‘verify’ internally and if it succeeds performs the following call:
```
bytes memory data = abi.encodePacked(forwardRequest.data, forwardRequest.from);
(success, ret) = forwardRequest.to.call{gas: forwardRequest.gas, value: forwardRequest.value}(data);
```
Regardless of whether the inner call succeeds or reverts, the nonce is incremented, invalidating the signature and preventing a replay of the request.

Note that `gas` parameter behaves according to EVM rules, specifically EIP-150.\
In case there is not enough `value` in the Forwarder the execution reverts.\
In case after the call there is a remaining Ether in the forwarder it is sent back to the signer. 
 
#### ERC-712 and 'suffixData' parameter
`suffixData` field must provide a valid 'tail' of an ERC-712 typed data.
For instance, in order to sign on the `ExtendedRequest` struct, the data will be a concatenation of the following chunks:
* `forwardRequest` fields will be RLP-encoded as-is, and variable-length `data` field will be hashed
* `uint256 x` will be appended entirely as-is
* `bytes z` will be hashed first
* `ExtraData extraData` will be hashed as a typed data

So a valid `suffixData` is calculated as following:
```
function calculateSuffixData(ExtendedRequest request) internal pure returns (bytes) {
    return abi.encode(request.x, keccak256(request.z), hashExtraData(request.extraData));
}

function hashExtraData(ExtraData extraData) internal pure returns (bytes32) {
    return keccak256(abi.encode(
            keccak256("ExtraData(uint256 a,uint256 b,uint256 c)"),
            extraData.a,
            extraData.b,
            extraData.c
        ));
}
```

#### Accepting Forwarded calls
In order to support calls performed via the Forwarder, the Recipient contract must implement ERC - RECIPIENT.

## Rationale
Further relying on `msg.sender` to authenticate end users by their externally-owned accounts is taking the Ethereum dapp ecosystem to a dead end.

A need for users to own Ether before they can interact with any contract has made a huge portion of use-cases for smart contracts non-viable,
which in turn limits the mass adoption and enforces this vicious cycle.

## Implementation
The implementation can be found at https://github.com/opengsn/forwarder

## Security Considerations
All contracts introducing support for the Forwarded requests thereby authorize this contract to perform any operation under any account.
It is critical that this contract has no vulnerabilities or centralization issues.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
